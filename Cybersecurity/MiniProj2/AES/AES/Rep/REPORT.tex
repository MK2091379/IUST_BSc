\def \Subject {گزارش پروژه}
\def \Course {امنیت سیستم‌های کامپیوتری}
\def \Author {سید معین کاظمی و علی رهنما علمداری}
\def \Report {مینی‌پروژه‌ی دوم}
\def \StudentNumber {۹۸۵۲۱۳۹۶ - ۹۸۵۲۱۲۱۶}
\begin{center}
\vspace{.4cm}
{\bf {\huge \Subject}}\\
{\bf \Large \Course}
\vspace{.2cm}
\end{center}
{\bf \Author }  \\
{\bf شماره دانشجویی:\ \StudentNumber}
\hspace{\fill} 
{\Large \Report} \\
\hrule
\vspace{0.8cm}
\clearpage
\section{مینی پروژه‌ی اول}
\subsection{سوال اول}
حمله‌های گوناگونی به 
\lr{DES}
شده است ولی در آخر 
\lr{brute force}
کاربردی ترین و کارآمد ترین آن‌هاست. البته حمله‌های دیگری که از لحاظ پیچیدگی بهتر از 
\lr{brute force} 
هستند وجود دارد اما اینگونه است که باید متن به مقدار بی‌نهایت در هر بار بیابد و بررسی کند که آیا پاسخ مورد نظر است یا خیر که از لحاظ عملی کمی غیر منطقی به نظر می‌رسد.
\\
در ادامه به بررسی هر یک از این حملات می‌پردازیم.
\\
\textit{\textbf{\underline{Linear}}}
\\
در نوع خطی به طور تقزیبی و نزدیک متن‌های رمز شده را پیدا می‌شود.حمله‌ها برای تولید blockcipher و streamcipher می باشند.equations model approximate به معاله‌ی n-2 و وابستگی‌ کلید‌های کاندید بستگی دارند.مورد اول در کاهش plaintext و مورد دوم نرخ موفق بودن حمله را بالا می‌برد. در این حمله ما به ۲ به توان ۴۳ متن اصلی نیاز داریم.
\\
\textit{\textbf{\underline{Device}}}
\\
فقط برای شکستن DES می‌باشد که همراه حمله‌ی خطی معروفترین حمله‌ها برای شکستن این نوع رمز‌گذاری هستند.ما به ۲ به توان ۵۱ plaintext نیاز داریم که احتمال موفقیت این نوع حمله هم حدود ۵۰ درصد است.
\\
\textit{\textbf{\underline{Key Related}}}
\\
در این حمله حمله‌گر یک plaintext را نه‌تنها روی کلید اصلی unknownK می‌داند بلکه روی کلید زیربخشی هم می‌داند.در این حمله،حمله‌گر نحوه‌ی تغییر کلید را مشخص می‌کند و تفاوت کلید‌ها را مشخص می‌کند اما نمی‌تواند آن‌ها را انتخاب کند.در این حمله در واقع حمله به پروتکل تبادل کلید انجام می‌شود که یکپارچگی کلید را ارائه نمی‌کند.مهاجم می تواند بیت های کلید را بدون درک پروتکل های به روزرسانی کلید صفحه کلید که کلیدها را با استفاده از یک تابع شناخته شده به‌روز‌رسانی می‌کند، آی‌پی کند.
\\
\textit{\textbf{\underline{Force Brute}}}
\\
کاربردی‌ترین و آسان‌ترین نوع حمله می‌باشد.در این حمله جایگشت‌های مختلف از کلید امتحان می‌شود تا متن رمز شسکته شده به دست آید.الگوریتم DES ۶۴ بیت کلید دارد که ۸ بیت از آن برای parity می‌باشد.با این حساب حتی یک کامپیوتر ساده هم می‌تواند به راحتی با این نوع حمله DES را بشکند.
\\
\textit{\textbf{\underline{Ⅾifferentiaⅼ}}}
\\
هدف اصلی، بررسی توزیع های آماری و الگو‌ها روی متن رمز شده می باشند که از روی این ها می توان کلید را بدست آورد. در واقع این حمله روی رابطه متن اصلی و متن رمز شده کار می‌کند و تفاوت ها را پیدا می‌کند و می فهمد اگر تغییر در متن اصلی یک تغییر غیر رندوم در متن رمز شده به وجود آورده پس می توان روابط را پیدا کرد و در نتیجه کلید را یافت.
\subsection{سوال دوم}
\textit{\textbf{\underline{دلیل ضروری بودن استفاده از الگوریتم AES}}}
\\
زمانی که الگوریتم استاندارد رمزگذاری داده ها، که به الگوریتم DES نیز معروف است، شکل گرفت و استاندارد شد، برای آن نسل از رایانه ها منطقی بود. مطابق با استانداردهای محاسباتی امروزی، نفوذ به الگوریتم DES هر سال آسان‌تر و سریع‌تر شد، همانطور که در تصویر زیر مشاهده می‌کنید.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/3.png}
\end{figure}
یک الگوریتم قوی‌تر نیاز روز بود، با اندازه‌های کلیدی طولانی‌تر و رمزهای قوی‌تر برای نفوذ. آنها DES سه گانه را برای رفع این مشکل ایجاد کردند، اما به دلیل سرعت نسبتاً کندتر آن هرگز به جریان اصلی تبدیل نشد. بنابراین، استاندارد رمزگذاری پیشرفته برای غلبه بر این اشکال به وجود آمد.
\\
الگوریتم رمزگذاری AES (همچنین به عنوان الگوریتم Rijndael شناخته می شود) یک الگوریتم رمزگذاری بلوک متقارن با اندازه بلوک/تکه 128 بیت است. این الگوریتم بلوک های فردی را با استفاده از کلیدهای 128، 192 و 256 بیتی تبدیل می کند. هنگامی که این بلوک ها را رمزگذاری کرد، آنها را به یکدیگر متصل می کند تا متن رمز را تشکیل دهد.
این شبکه مبتنی بر یک شبکه substitution-permutation است که به عنوان شبکه SP نیز شناخته می شود. این شامل یک سری عملیات مرتبط است، از جمله جایگزینی ورودی‌ها با خروجی‌های خاص (جایگزینی) و سایر عملیات‌های مربوط به تغییر بیت (جایگشت).
\\
\textit{\textbf{\underline{ویژگی‌های AES}}}
\\
شبکه جایگزینی-جایگشتی: همانطور که در مورد الگوریتم DES دیده می شود، به جای ساختار رمزی Feistel روی ساختار شبکه SP کار می کند.
\\
گسترش کلید: در مرحله اول یک کلید را بالا می برد که بعداً به چندین کلید که در راندهای جداگانه استفاده می شود گسترش می یابد.
\\
داده های بایت: الگوریتم رمزگذاری AES به جای داده های بیتی، عملیات روی داده های بایتی انجام می دهد. بنابراین اندازه بلوک 128 بیتی را در طول فرآیند رمزگذاری 16 بایت در نظر می گیرد.
\\
طول کلید: تعداد دورهایی که باید انجام شوند به طول کلیدی که برای رمزگذاری داده ها استفاده می شود بستگی دارد. اندازه کلید 128 بیتی دارای ده دور، اندازه کلید 192 بیتی دارای 12 دور و اندازه کلید 256 بیتی دارای 14 دور است.
\\
\textit{\textbf{\underline{نحوه‌ی کارکرد}}}
\\
برای درک نحوه عملکرد AES، ابتدا باید یاد بگیرید که چگونه اطلاعات را بین چند مرحله منتقل می کند. از آنجایی که یک بلوک 16 بایتی است، یک ماتریس 4x4 داده ها را در یک بلوک نگه می دارد و هر سلول یک بایت اطلاعات را در خود جای می دهد.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/4.png}
\end{figure}
ماتریس نشان داده شده در تصویر بالا به عنوان آرایه حالت شناخته می شود. به طور مشابه، کلید مورد استفاده در ابتدا به کلیدهای (n+1) گسترش می یابد که n تعداد دورهایی است که باید در فرآیند رمزگذاری دنبال شوند. بنابراین برای یک کلید 128 بیتی، تعداد دورها 16 است، بدون صفر. از کلیدهایی که باید تولید شوند 1+10 است که در مجموع 11 کلید است
\\
\textit{\textbf{\underline{مراحل کار}}}
\\
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/5.png}
\end{figure}
مراحل ذکر شده باید برای هر بلوک به صورت متوالی دنبال شود. پس از رمزگذاری موفقیت آمیز بلوک های جداگانه، آنها را به یکدیگر متصل می کند تا متن رمز نهایی را تشکیل دهد. مراحل به شرح زیر است:
\\
افزودن :round-key داده های بلوک ذخیره شده در آرایه حالت را از طریق یک تابع XOR با اولین کلید تولید شده (K0) منتقل می کنید. آرایه حالت حاصل را به عنوان ورودی به مرحله بعدی ارسال می کند.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/6.png}
\end{figure}
:Sub-Bytes در این مرحله هر بایت آرایه حالت را به هگزادسیمال تبدیل می کند که به دو قسمت مساوی تقسیم می شود. این بخش‌ها ردیف‌ها و ستون‌هایی هستند که با یک جعبه جایگزین (S-Box) نقشه‌برداری می‌شوند تا مقادیر جدیدی برای آرایه حالت نهایی ایجاد کنند.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/7.png}
\end{figure}
:Shift-Rows عناصر ردیف را بین یکدیگر جابجا می کند. از ردیف اول می گذرد. عناصر را در ردیف دوم، یک موقعیت به سمت چپ جابجا می کند. همچنین عناصر را از ردیف سوم دو موقعیت متوالی به چپ و ردیف آخر را سه موقعیت به چپ می‌برد.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/8.png}
\end{figure}
:Mix-Columns یک ماتریس ثابت را با هر ستون در آرایه حالت ضرب می کند تا یک ستون جدید برای آرایه حالت بعدی بدست آورد. هنگامی که همه ستون ها با یک ماتریس ثابت ضرب می شوند، آرایه حالت خود را برای مرحله بعدی دریافت می کنید. این مرحله خاص قرار نیست در دور آخر انجام شود.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/9.png}
\end{figure}
افزودن :round-key کلید مربوطه برای دور XOR است که آرایه حالت در مرحله قبل به دست آمده است. اگر این آخرین دور باشد، آرایه حالت حاصل تبدیل به متن رمزی برای بلوک خاص می شود. در غیر این صورت، به عنوان ورودی آرایه حالت جدید برای دور بعدی ارسال می شود.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/10.png}
\end{figure}
به مثال زیر دقت کنید:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/11.png}
\end{figure}
همانطور که در تصویر بالا می بینید، متن اصلی و رمزگذاری کلیدها را قبل از شروع عملیات به فرمت هگز تبدیل می کند. بر این اساس، همانطور که در زیر مشاهده می کنید، می توانید کلیدهای ده دور بعدی را تولید کنید.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/12.png}
\end{figure}
شما باید همان مراحلی را که در بالا توضیح داده شد دنبال کنید، آرایه حالت را به ترتیب استخراج کرده و آن را به عنوان ورودی به دور بعدی ارسال کنید. مراحل به شرح زیر است:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/13.png}
\end{figure}
:Sub-Bytes عناصر را از یک S-Box 16x16 عبور می دهد تا یک آرایه حالت کاملاً جدید به دست آید.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/14.png}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/15.png}
\end{figure}
این آرایه حالت اکنون متن رمز نهایی برای این دور خاص است. این ورودی برای دور بعدی می شود. بسته به طول کلید، مراحل بالا را تکرار می کنید تا دور 10 را کامل کنید و پس از آن متن رمز نهایی را دریافت می کنید.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/16.png}
\end{figure}
در ادامه ما مراحل بالا را به صورت عملی با استفاده از زبان پایتون شبیه‌سازی کرده ایم که نمونه تست آن را در تصویر زیر می‌توانید مشاهده کنید.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/2.png}
\end{figure}